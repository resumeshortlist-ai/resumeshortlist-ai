From 30b2bd59186efcfec79f9f63ff2290153bc7a385 Mon Sep 17 00:00:00 2001
From: Codex <codex@openai.com>
Date: Mon, 22 Dec 2025 16:29:25 +0000
Subject: [PATCH] Admin resume repository: Cloudflare R2 storage, contact
 capture, and admin UI

### Motivation
- Provide a persistent admin workflow so uploaded resumes can be reviewed, revised, and delivered to customers.
- Capture customer contact details (full name, email, phone) for delivery, follow-ups and refunds.
- Move binary file storage out of MongoDB to Cloudflare R2 for scalable object storage and simpler downloads.
- Enforce basic contact validation so uploads include identity information before analysis/delivery.

### Description
- Backend: added Cloudflare R2 helpers (`_r2_config`, `_r2_client`, `_r2_upload_bytes`, `_r2_download_bytes`) and store `original_r2_key`/`revised_r2_key` in `resume_requests` instead of binary blobs.
- Backend: added admin endpoints `GET /api/admin/orders`, `GET /api/admin/orders/{upload_id}/file`, `POST /api/admin/orders/{upload_id}/revised`, and `POST /api/admin/orders/{upload_id}/send-revision`, plus SMTP helper `_send_revision_email` to deliver revised resumes.
- Backend: capture and persist customer contact on upload and checkout (extended `CheckoutRequest` with `name` and `phone`), and update order/payment status in `verify-session`.
- Frontend: require `Full Name` and `Email` on the upload screen (block uploads until provided), include contact fields in the checkout sidebar, and replace the demo admin page with a functional `Admin.jsx` that lists orders and supports download/upload/email actions.

### Testing
- Started the frontend development server with `npm start` and the app compiled successfully.
- Attempted an automated Playwright screenshot of the upload/admin pages but the run failed with `net::ERR_CONNECTION_REFUSED` (browser could not connect), so end-to-end UI capture failed.
- No automated backend unit or integration tests were executed for the new endpoints or email/R2 flows.
- Environment variables for Cloudflare R2 and backend were added to the deployment (Render/Vercel) and services were redeployed for manual verification (manual checks recommended).
---
 backend/server.py                      | 305 ++++++++++++++++++++++++- 
 frontend/src/components/FileUpload.jsx |   9 +-
 frontend/src/pages/ATSResults.jsx      |  72 +++++-
 frontend/src/pages/Admin.jsx           | 205 +++++++++++++----
 4 files changed, 533 insertions(+), 58 deletions(-)

diff --git a/backend/server.py b/backend/server.py
index 0faa57c..dc92ce1 100644
--- a/backend/server.py
+++ b/backend/server.py
@@ -1,4 +1,4 @@
-from fastapi import FastAPI, APIRouter, UploadFile, File, Form, HTTPException, Request
+from fastapi import FastAPI, APIRouter, UploadFile, File, Form, HTTPException, Request, Response
 from dotenv import load_dotenv
 from starlette.middleware.cors import CORSMiddleware
 from motor.motor_asyncio import AsyncIOMotorClient
@@ -12,11 +12,15 @@ from datetime import datetime, timezone
 import io
 import json
 import time
+import smtplib
+import ssl
+from email.message import EmailMessage
 
 import pypdf
 import docx
 import stripe
 from openai import OpenAI
+import boto3
 
 
 ROOT_DIR = Path(__file__).parent
@@ -71,6 +75,8 @@ class CheckoutRequest(BaseModel):
     include_interview_prep: bool = False
     upload_id: Optional[str] = None
     email: Optional[str] = None
+    name: Optional[str] = None
+    phone: Optional[str] = None
 
 
 def extract_text_from_pdf(file_content: bytes) -> str:
@@ -177,13 +183,137 @@ Be strict. Typical score 45â€“65.
     }
 
 
+def _serialize_order(order: Dict[str, Any]) -> Dict[str, Any]:
+    if not order:
+        return {}
+    customer = order.get("customer") or {}
+    payment = order.get("payment") or {}
+    return {
+        "upload_id": order.get("upload_id"),
+        "status": order.get("status"),
+        "tier": order.get("tier"),
+        "score": order.get("score"),
+        "created_at": order.get("created_at").isoformat() if order.get("created_at") else None,
+        "original_filename": order.get("original_filename"),
+        "revised_filename": order.get("revised_filename"),
+        "original_r2_key": order.get("original_r2_key"),
+        "revised_r2_key": order.get("revised_r2_key"),
+        "customer": {
+            "name": customer.get("name"),
+            "email": customer.get("email"),
+            "phone": customer.get("phone"),
+        },
+        "payment": {
+            "session_id": payment.get("session_id"),
+            "status": payment.get("status"),
+            "paid_at": payment.get("paid_at").isoformat() if payment.get("paid_at") else None,
+        },
+    }
+
+def _smtp_config() -> Dict[str, Any]:
+    host = os.environ.get("SMTP_HOST")
+    if not host:
+        return {}
+    return {
+        "host": host,
+        "port": int(os.environ.get("SMTP_PORT", "587")),
+        "username": os.environ.get("SMTP_USER"),
+        "password": os.environ.get("SMTP_PASSWORD"),
+        "sender": os.environ.get("SMTP_FROM") or os.environ.get("SMTP_USER"),
+    }
+
+def _r2_config() -> Dict[str, Any]:
+    bucket = os.environ.get("R2_BUCKET")
+    account_id = os.environ.get("R2_ACCOUNT_ID")
+    access_key = os.environ.get("R2_ACCESS_KEY_ID")
+    secret_key = os.environ.get("R2_SECRET_ACCESS_KEY")
+    if not all([bucket, account_id, access_key, secret_key]):
+        return {}
+    endpoint = os.environ.get("R2_ENDPOINT") or f"https://{account_id}.r2.cloudflarestorage.com"
+    return {
+        "bucket": bucket,
+        "endpoint": endpoint,
+        "access_key": access_key,
+        "secret_key": secret_key,
+    }
+
+def _r2_client():
+    config = _r2_config()
+    if not config:
+        return None
+    return boto3.client(
+        "s3",
+        endpoint_url=config["endpoint"],
+        aws_access_key_id=config["access_key"],
+        aws_secret_access_key=config["secret_key"],
+        region_name="auto",
+    )
+
+def _r2_key(upload_id: str, filename: str, variant: str) -> str:
+    extension = ""
+    if filename and "." in filename:
+        extension = filename.split(".")[-1].lower()
+    suffix = f".{extension}" if extension else ""
+    return f"uploads/{upload_id}/{variant}{suffix}"
+
+def _r2_upload_bytes(key: str, content: bytes, content_type: str) -> None:
+    client = _r2_client()
+    config = _r2_config()
+    if not client or not config:
+        raise RuntimeError("R2 is not configured. Set R2_BUCKET, R2_ACCOUNT_ID, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY.")
+    client.put_object(Bucket=config["bucket"], Key=key, Body=content, ContentType=content_type)
+
+def _r2_download_bytes(key: str) -> bytes:
+    client = _r2_client()
+    config = _r2_config()
+    if not client or not config:
+        raise RuntimeError("R2 is not configured. Set R2_BUCKET, R2_ACCOUNT_ID, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY.")
+    response = client.get_object(Bucket=config["bucket"], Key=key)
+    return response["Body"].read()
+
+def _send_revision_email(
+    *,
+    recipient: str,
+    customer_name: str,
+    subject: str,
+    body: str,
+    attachment_name: str,
+    attachment_bytes: bytes,
+    attachment_type: str,
+) -> None:
+    config = _smtp_config()
+    if not config:
+        raise RuntimeError("SMTP is not configured. Set SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASSWORD, SMTP_FROM.")
+    msg = EmailMessage()
+    msg["Subject"] = subject
+    msg["From"] = config["sender"]
+    msg["To"] = recipient
+    msg.set_content(body)
+    msg.add_attachment(attachment_bytes, maintype=attachment_type.split("/")[0], subtype=attachment_type.split("/")[1], filename=attachment_name)
+    context = ssl.create_default_context()
+    with smtplib.SMTP(config["host"], config["port"]) as server:
+        server.starttls(context=context)
+        if config.get("username") and config.get("password"):
+            server.login(config["username"], config["password"])
+        server.send_message(msg)
+
@@ -191,7 +321,7 @@ async def health():
     return {"ok": True, "db": bool(db), "openai": bool(openai_client), "stripe": bool(stripe.api_key)}
 
 
 @api_router.post("/analyze")
-async def analyze_resume(file: UploadFile = File(...)):
+async def analyze_resume(file: UploadFile = File(...), name: str = Form(...), email: str = Form(...)):
@@ -218,12 +348,16 @@ async def analyze_resume(file: UploadFile = File(...)):
     if db:
         try:
+            original_key = _r2_key(upload_id, file.filename or "resume", "original")
+            _r2_upload_bytes(original_key, content, file.content_type or "application/octet-stream")
             await db.resume_requests.insert_one(
                 {"upload_id": upload_id, "created_at": datetime.now(timezone.utc), "status": "analysis_complete",
-                 "tier": analysis.get("suggested_tier"), "score": analysis.get("score"),
-                 "original_filename": file.filename, "original_content_type": file.content_type or "application/octet-stream",
-                 "analysis": analysis}
+                 "tier": analysis.get("suggested_tier"), "score": analysis.get("score"),
+                 "original_filename": file.filename, "original_content_type": file.content_type or "application/octet-stream",
+                 "original_r2_key": original_key,
+                 "customer": {"name": name, "email": email},
+                 "analysis": analysis}
             )
         except Exception as e:
             logger.error(f"DB insert failed (resume_requests): {e}")
... (rest of patch continues) ...
